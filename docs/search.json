[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Introduction",
    "section": "",
    "text": "In America, elections are mostly administered by local governments with varying degrees of standardization enforced by the state and federal governments. In a state like Wisconsin, analyzing election results requires combining data across a variety of sources. This document is an explanation and tutorial on how to do that.\nFollow along in the associated Github repository for data and code.\nI’ve accumulated the information in these pages from working closely with Wisconsin election data over the past 7 years. I’m grateful to the many local and state election workers who’ve written documentation or responded to my calls and emails. Any errors contained within are mine alone. If you spot something wrong, please send an email to john.d.johnson@marquette.edu.\nThis is a living document, which I plan to update with additional content in the future."
  },
  {
    "objectID": "DemographicsAndVotes.html",
    "href": "DemographicsAndVotes.html",
    "title": "Combining Demographic & Election data",
    "section": "",
    "text": "Here is a simple example, calculating the relative performance of the Democratic candidate in gubernatorial and presidential election in City of Milwaukee wards. I present the results separately for wards where the majority of adults are Black, non-Hispanic white, Hispanic or Latino, etc.\n\nRetrieve election results\n\n\nShow the code\nlibrary(tidyverse)\nlibrary(gt)\nlibrary(broom)\nlibrary(gtsummary)\nknitr::opts_chunk$set(warning = FALSE, message = FALSE)\n\norig.wec <- read_csv(here::here(\"election-data/OriginalWEC_Pres-GOV_2012-2022_ReportingUnits.csv\"))\n\n\nThe elections file contains the official election results for each reporting unit in each election year. My analysis is limited to just the City of Milwaukee, where each reporting unit is one ward and wards stayed the same from 2012-2020. Their boundaries then changed to accomodate redistricting in 2022.\nSee the file election-data/official-wec/CombineFiles.R for a demonstration of how to clean and combine official WEC ward returns.\n\n\nShow the code\n# subset city of milwaukee wards\nmke.ward.votes <- orig.wec %>%\n  filter(county == \"MILWAUKEE\",\n         str_detect(rep_unit, \"CITY OF MILWAUKEE\")) %>%\n  mutate(ward = as.numeric(word(rep_unit, -1))) %>%\n  select(ward, year, office, total, rep, dem)\nmke.ward.votes\n\n\n# A tibble: 1,977 × 6\n    ward  year office    total   rep   dem\n   <dbl> <dbl> <chr>     <dbl> <dbl> <dbl>\n 1     1  2012 president  1489   297  1185\n 2     2  2012 president   523    23   500\n 3     3  2012 president  1138   229   909\n 4     4  2012 president  1868   275  1576\n 5     5  2012 president   917   125   789\n 6     6  2012 president  1875   462  1395\n 7     7  2012 president   679   194   480\n 8     8  2012 president  1553   371  1172\n 9     9  2012 president   857   126   725\n10    10  2012 president  1278   346   926\n# … with 1,967 more rows\n\n\n\n\nRetrieve ward demographics\nNext, I retrieve the ward statistics for voting age population by race/ethnicity. See the chapter on “Ward Demographics” for details about calculating this. There are two Milwaukee ward demographic files, one containing statistics for the 2011 ward vintage, and the other containing the 2022 ward vintage.\nI combine the two into a single dataframe in long format. There is 1 row for each unique combination of ward, year, and demographic group. The following abbreviations are used:\n\nvap = voting age population\naian = Alaska Native or Pacific Islander (non-Hispanic)\nasian = Asian (non-Hispanic)\nblack = Black or African American (non-Hispanic)\nhisp = Hispanic or Latino (any race)\nwhite = white (non-Hispanic)\nother = other (non-Hispanic)\ntwo = 2 or more race (non-Hispanic)\n\n\n\nShow the code\n# city of milwaukee ward demographics, wards used from 2012-2020\nmke.2011ward.demographics <- read_csv(here::here(\"data/ward-demographics/Wards2011_VAP_2010to2020.csv\")) %>%\n  filter(str_detect(ward_2011, \"^Milwaukee - C\")) %>%\n  pivot_longer(cols = -c(1:2), names_to = \"year\", values_to = \"count\") %>%\n  mutate(year = as.numeric(str_sub(year, -4, -1)),\n         ward = as.numeric(word(ward_2011, -1))) %>%\n  select(ward, year, group, count) %>%\n  group_by(ward, year) %>%\n  mutate(pct = (count/count[group == \"vap\"])*100) %>%\n  ungroup()\n\n# city of milwaukee ward demographics, wards used from 2022-\nmke.2022ward.demographics <- read_csv(here::here(\"data/ward-demographics/Wards2022_VAP_2020.csv\")) %>%\n  filter(str_detect(ward_2022, \"^Milwaukee - C\")) %>%\n  # set year to 2022, as this is the election year these wards apply to\n  mutate(year = 2022,\n         ward = as.numeric(word(ward_2022, -1))) %>%\n  rename(count = count_2020) %>%\n  select(ward, year, group, count) %>%\n  group_by(ward, year) %>%\n  mutate(pct = (count/count[group == \"vap\"])*100) %>%\n  ungroup()\n\nmke.combined.ward.demographics <- bind_rows(mke.2011ward.demographics,\n                                            mke.2022ward.demographics) %>%\n  arrange(ward, year, group)\nmke.combined.ward.demographics\n\n\n# A tibble: 20,718 × 5\n    ward  year group     count     pct\n   <dbl> <dbl> <chr>     <dbl>   <dbl>\n 1     1  2010 vap        2604 100    \n 2     1  2010 vap_aian      6   0.230\n 3     1  2010 vap_asian   120   4.61 \n 4     1  2010 vap_black  1138  43.7  \n 5     1  2010 vap_hisp    426  16.4  \n 6     1  2010 vap_nhpi      0   0    \n 7     1  2010 vap_other     4   0.154\n 8     1  2010 vap_two      50   1.92 \n 9     1  2010 vap_white   860  33.0  \n10     1  2012 vap        2583 100    \n# … with 20,708 more rows\n\n\n\n\ncalculate ward majority group\nI then determine which group, if any, makes up at outright majority of the ward’s voting age population in that year.\n\n\nShow the code\nmke.ward.majority <- mke.combined.ward.demographics %>%\n  filter(group != \"vap\") %>%\n  group_by(year, ward) %>%\n  slice_max(order_by = count, n = 1, with_ties = F) %>%\n  ungroup() %>%\n  mutate(vap_majority = if_else(pct > 50,\n                                true = word(group, -1, sep = \"_\"),\n                                false = \"no majority\")) %>%\n  select(ward, year, vap_majority)\nmke.ward.majority\n\n\n# A tibble: 2,302 × 3\n    ward  year vap_majority\n   <dbl> <dbl> <chr>       \n 1     1  2010 no majority \n 2     2  2010 black       \n 3     3  2010 black       \n 4     4  2010 black       \n 5     5  2010 black       \n 6     6  2010 no majority \n 7     7  2010 no majority \n 8     8  2010 black       \n 9     9  2010 black       \n10    10  2010 no majority \n# … with 2,292 more rows\n\n\n\n\naggregate election results by ward majority group\nThen, I merge the ward majority dataframe with the election results dataframe, and aggregate the votes by majority group.\n\n\nShow the code\nmke.ward.majority.totals <- mke.ward.votes %>%\n  inner_join(mke.ward.majority) %>%\n  group_by(year, office, vap_majority) %>%\n  summarise(wards = n(),\n            across(.cols = where(is.numeric), .fns = sum)) %>%\n  ungroup() %>%\n  mutate(dem_pct_2pty = (dem/(rep + dem))*100) %>%\n  filter(total > 0)\nmke.ward.majority.totals\n\n\n# A tibble: 31 × 9\n    year office    vap_majority wards  ward  total   rep    dem dem_pct_2pty\n   <dbl> <chr>     <chr>        <int> <dbl>  <dbl> <dbl>  <dbl>        <dbl>\n 1  2012 president asian            1   171    230    10    218         95.6\n 2  2012 president black          136 12679 123308  7429 115406         94.0\n 3  2012 president hisp            44 11056  20122  2861  17117         85.7\n 4  2012 president no majority     26  3598  21584  3968  17377         81.4\n 5  2012 president white          118 25487 122143 42419  77692         64.7\n 6  2014 governor  asian            1   171    110     3    106         97.2\n 7  2014 governor  black          138 12541  90805  7211  82923         92.0\n 8  2014 governor  hisp            45 11340  11902  2453   9277         79.1\n 9  2014 governor  no majority     26  4055  14127  3370  10574         75.8\n10  2014 governor  white          115 24884  88390 33619  53455         61.4\n# … with 21 more rows\n\n\nFinally, I use the {{gt}} package to create a nicely formatted table of results.\n\n\nShow the code\nmke.ward.majority.totals %>%\n  mutate(office_year = paste(year, office)) %>%\n  select(office_year, vap_majority, wards, dem_share = dem_pct_2pty) %>%\n  pivot_wider(names_from = vap_majority, values_from = c(dem_share, wards),\n              names_glue = \"{vap_majority}:{.value}\") %>%\n  select(office_year, starts_with(\"black\"), starts_with(\"white\"), starts_with(\"hisp\"),\n         starts_with(\"no majority\"), starts_with(\"asian\")) %>%\n  gt(rowname_col = \"office_year\") %>%\n  tab_spanner_delim(\":\") %>%\n  fmt_percent(columns = contains(\"dem_share\"), decimals = 0, scale = F) %>%\n  data_color(columns = contains(\"dem_share\"), \n             domain = c(min(mke.ward.majority.totals$dem_pct_2pty),\n                        max(mke.ward.majority.totals$dem_pct_2pty)),\n             palette = \"Blues\") %>%\n  tab_header(title = \"Election results in City of Milwaukee wards\",\n             subtitle = \"by the racial/ethnic majority group of adults in each ward\") %>%\n  tab_footnote(\"Democratic candidate's share of the two-party vote\",\n               locations = cells_column_labels(contains(\"dem_share\"))) %>%\n  tab_footnote(\"2012-2018 ward population statistics are linearly interpolated using 2010 and 2020 census data. 2020 and 2022 statistics both use 2020 census data.\",\n               locations = cells_column_labels(contains(\"wards\"))) %>%\n  tab_footnote(\"The wards used in 2022 were different than the wards used from 2012-2020.\",\n               locations = cells_stub(rows = 6))\n\n\n\n\n\n\n  \n    \n      Election results in City of Milwaukee wards\n    \n    \n      by the racial/ethnic majority group of adults in each ward\n    \n    \n      \n      \n        black\n      \n      \n        white\n      \n      \n        hisp\n      \n      \n        no majority\n      \n      \n        asian\n      \n    \n    \n      dem_share1\n      wards2\n      dem_share1\n      wards2\n      dem_share1\n      wards2\n      dem_share1\n      wards2\n      dem_share1\n      wards2\n    \n  \n  \n    2012 president\n94%\n136\n65%\n118\n86%\n44\n81%\n26\n96%\n1\n    2014 governor\n92%\n138\n61%\n115\n79%\n45\n76%\n26\n97%\n1\n    2016 president\n93%\n141\n69%\n110\n83%\n46\n79%\n27\n96%\n1\n    2018 governor\n92%\n142\n70%\n109\n83%\n46\n79%\n27\n97%\n1\n    2020 president\n91%\n143\n71%\n106\n78%\n46\n76%\n28\n75%\n1\n    2022 governor3\n92%\n144\n75%\n119\n81%\n43\n78%\n37\n90%\n1\n  \n  \n  \n    \n      1 Democratic candidate's share of the two-party vote\n    \n    \n      2 2012-2018 ward population statistics are linearly interpolated using 2010 and 2020 census data. 2020 and 2022 statistics both use 2020 census data.\n    \n    \n      3 The wards used in 2022 were different than the wards used from 2012-2020.\n    \n  \n\n\n\n\n\n\nlinear regression\nExtrapolating individual voter behavior from the table above risks committing the ecological fallacy. To better measure how demographics correlate with election results, I construct a regression model.\nOverall, the model confirms the correlations revealed in the simple ward majority table. Keep reading for more details.\nFirst, I prepare the data, so that I am left with 1 row per ward in each election. I have variables for the total number of voters, the Democratic candidate’s share of the 2-party vote, and the proportion of adults made up by each race. I create a combined other category containing all adults who aren’t Black, white, Hispanic/Latino, or Asian. I also add dummy variables for each election year beginning in 2014.\n\n\nShow the code\nwards.votes.vap.pct <- mke.combined.ward.demographics %>%\n  select(-pct) %>%\n  pivot_wider(names_from = group, values_from = count) %>%\n  mutate(vap_other2 = vap_other + vap_two + vap_aian + vap_nhpi) %>%\n  inner_join(mke.ward.votes) %>%\n  select(ward, year, office, total, dem, rep, vap, vap_black, vap_white,\n         vap_hisp, vap_asian, vap_other2) %>%\n  # calculate percentages\n  mutate(total_2party = dem + rep,\n         pdem = (dem/total_2party)*100,\n         pvap_black = (vap_black/vap)*100,\n         pvap_white = (vap_white/vap)*100,\n         pvap_hisp = (vap_hisp/vap)*100,\n         pvap_asian = (vap_asian/vap)*100,\n         pvap_other2 = (vap_other2/vap)*100) %>%\n  select(ward, year, office, total_2party, vap, starts_with(\"p\")) %>%\n  # add dummy variables for each election, 2014-2022\n  mutate(x2014 = if_else(year == 2014, 1, 0),\n         x2016 = if_else(year == 2016, 1, 0),\n         x2018 = if_else(year == 2018, 1, 0),\n         x2020 = if_else(year == 2020, 1, 0),\n         x2022 = if_else(year == 2022, 1, 0)) %>%\n  # remove ward-years with either no votes or no adults\n  filter(!is.na(pdem),\n         vap > 0)\nglimpse(wards.votes.vap.pct)\n\n\nRows: 1,962\nColumns: 16\n$ ward         <dbl> 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 4, …\n$ year         <dbl> 2012, 2014, 2016, 2018, 2020, 2022, 2012, 2014, 2016, 201…\n$ office       <chr> \"president\", \"governor\", \"president\", \"governor\", \"presid…\n$ total_2party <dbl> 1482, 971, 1157, 1000, 1164, 756, 523, 297, 391, 273, 352…\n$ vap          <dbl> 2583.0, 2562.0, 2541.0, 2520.0, 2499.0, 2499.0, 869.4, 87…\n$ pdem         <dbl> 79.95951, 76.93100, 80.81245, 80.80000, 83.67698, 82.6719…\n$ pvap_black   <dbl> 47.27062, 50.89774, 54.58481, 58.33333, 62.14486, 62.1448…\n$ pvap_white   <dbl> 29.910956, 26.744731, 23.526171, 20.253968, 16.926771, 16…\n$ pvap_hisp    <dbl> 15.842044, 15.316159, 14.781582, 14.238095, 13.685474, 13…\n$ pvap_asian   <dbl> 4.5063879, 4.4028103, 4.2975207, 4.1904762, 4.0816327, 4.…\n$ pvap_other2  <dbl> 2.469996, 2.638564, 2.809917, 2.984127, 3.161265, 3.16126…\n$ x2014        <dbl> 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, …\n$ x2016        <dbl> 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, …\n$ x2018        <dbl> 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, …\n$ x2020        <dbl> 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, …\n$ x2022        <dbl> 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, …\n\n\nI then create a regression model using this formula. The independent variable is the Democratic candidate’s share of the two-party vote. The regressors are the Black, Hispanic, Asian, and other adult population shares, each matched with an interaction term for the 2014, 2016, 2018, 2020, and 2022 elections. Each ward is weighted by the number of adults living in it.\n$lm(pdem ~ pvap_blackx2014 + pvap_blackx2016 + pvap_blackx2018 + pvap_blackx2020 + pvap_blackx2022 + pvap_hispx2014 + pvap_hispx2016 + pvap_hispx2018 + pvap_hispx2020 + pvap_hispx2022 + pvap_asianx2014 + pvap_asianx2016 + pvap_asianx2018 + pvap_asianx2020 + pvap_asianx2022 + pvap_other2x2014 + pvap_other2x2016 + pvap_other2x2018 + pvap_other2x2020 + pvap_other2x2022, weights = vap)\n\n\nShow the code\npvap.lm <- lm(pdem ~ pvap_black*x2014 + pvap_black*x2016 + pvap_black*x2018 + pvap_black*x2020 + pvap_black*x2022 +\n     pvap_hisp*x2014 + pvap_hisp*x2016 + pvap_hisp*x2018 + pvap_hisp*x2020 + pvap_hisp*x2022 +\n     pvap_asian*x2014 + pvap_asian*x2016 + pvap_asian*x2018 + pvap_asian*x2020 + pvap_asian*x2022 +\n     pvap_other2*x2014 + pvap_other2*x2016 + pvap_other2*x2018 + pvap_other2*x2020 + pvap_other2*x2022,\n   data = wards.votes.vap.pct, weights = vap)\n\n\nHere’s how to interpret the results. The intercept is a ward in the 2012 presidential election where 100% of adults are (non-Hispanic) white. The model predicts that this ward would’ve given Barack Obama 49% of the two-party vote. For every additional 1 percentage point increase in the Black share of the population, the model predicts the Democratic vote share to grow by 0.46 points; for every 1 point increase in the Latino share, a 0.37 point increase; and for every 1 point increase in the Asian share, a 0.30 point increase.\nIn the 2014 gubernatorial race the results are not significantly different from 2012 for changes in the white, Black, Latino, and Asian population.\nChanges are statistically significant in the 2016 presidential race. Relative to 2012, the predicted Democratic vote share in an entirely white ward grows by 8.2 percentage points. Every one point increase in the Black share of the population correlates with a slight (though statistically significant) 0.07 percentage point decrease in Democratic support, relative to 2012. For a one point in crease in the Latino population share, the Democratic share decreases by 0.13 points.\nThe next elections show a continuation of this trend. Relative to each group’s pattern in 2012, Democratic support increases among white adults and decreases among Black and Latino adults.\nHere are the statistics for the 2022 presidential race, relative to 2012. In a hypothetically entirely white ward, the Democratic share grows by 21 percentage points. The increase in Democratic support for every 1-point increase in the Black population slips by 0.18 percentage points. It drops by 0.28 points for each 1-point increase in the Latino population. Margins of error are larger among the smaller Asian population, but the model even finds a statistically significant drop in Democratic support here.\n\n\nShow the code\ntbl_regression(pvap.lm, intercept = T) %>%\n add_glance_source_note(\n    include = everything(),\n    text_interpret = c(\"md\", \"html\"),\n    sep1 = \" = \",\n    sep2 = \"; \"\n  )\n\n\n\n\n\n\n  \n    \n    \n      Characteristic\n      Beta\n      95% CI1\n      p-value\n    \n  \n  \n    (Intercept)\n49\n45, 53\n<0.001\n    pvap_black\n0.46\n0.43, 0.49\n<0.001\n    x2014\n-4.4\n-10, 1.3\n0.13\n    x2016\n8.2\n2.2, 14\n0.007\n    x2018\n9.3\n3.3, 15\n0.003\n    x2020\n18\n12, 23\n<0.001\n    x2022\n21\n15, 26\n<0.001\n    pvap_hisp\n0.37\n0.33, 0.41\n<0.001\n    pvap_asian\n0.30\n0.11, 0.50\n0.002\n    pvap_other2\n2.9\n1.7, 4.2\n<0.001\n    pvap_black * x2014\n0.04\n-0.01, 0.08\n0.086\n    pvap_black * x2016\n-0.07\n-0.11, -0.03\n0.002\n    pvap_black * x2018\n-0.09\n-0.13, -0.04\n<0.001\n    pvap_black * x2020\n-0.15\n-0.20, -0.11\n<0.001\n    pvap_black * x2022\n-0.18\n-0.22, -0.14\n<0.001\n    x2014 * pvap_hisp\n-0.03\n-0.10, 0.03\n0.3\n    x2016 * pvap_hisp\n-0.11\n-0.18, -0.05\n<0.001\n    x2018 * pvap_hisp\n-0.13\n-0.20, -0.07\n<0.001\n    x2020 * pvap_hisp\n-0.29\n-0.35, -0.22\n<0.001\n    x2022 * pvap_hisp\n-0.28\n-0.35, -0.22\n<0.001\n    x2014 * pvap_asian\n-0.10\n-0.37, 0.17\n0.5\n    x2016 * pvap_asian\n-0.13\n-0.39, 0.14\n0.4\n    x2018 * pvap_asian\n-0.23\n-0.49, 0.03\n0.085\n    x2020 * pvap_asian\n-0.45\n-0.70, -0.19\n<0.001\n    x2022 * pvap_asian\n-0.45\n-0.71, -0.20\n<0.001\n    x2014 * pvap_other2\n-0.16\n-1.9, 1.5\n0.8\n    x2016 * pvap_other2\n-1.5\n-3.1, 0.10\n0.066\n    x2018 * pvap_other2\n-1.7\n-3.2, -0.13\n0.033\n    x2020 * pvap_other2\n-2.4\n-3.8, -0.94\n0.001\n    x2022 * pvap_other2\n-2.4\n-3.8, -0.92\n0.001\n  \n  \n    \n      R² = 0.697; Adjusted R² = 0.693; Sigma = 283; Statistic = 153; p-value = <0.001; df = 29; Log-likelihood = -6,892; AIC = 13,846; BIC = 14,019; Deviance = 154,298,218; Residual df = 1,932; No. Obs. = 1,962\n    \n  \n  \n    \n      1 CI = Confidence Interval\n    \n  \n\n\n\n\nThese plots visualize the changing coefficients in Democratic support for each 1-point increase in the Asian, Black, and Latino populations, relative to 2012.\n\n\nShow the code\nbroom::tidy(pvap.lm, conf.int = T) %>% filter(str_detect(term, \"x2\"),\n                        str_detect(term, \":\")) %>%\n  mutate(race = str_extract(term, \"pvap.*:|pvap.*$\"),\n         year = str_extract(term, \"x.*:|x.*$\"),\n         race = str_remove(race, \":\"),\n         year = str_remove(year, \":\")) %>%\n  filter(race != \"pvap_other2\") %>%\n  ggplot() +\n  geom_hline(yintercept = 0, linetype = \"dashed\") +\n  geom_pointrange(aes(x = year, y = estimate, ymin = conf.low, ymax = conf.high)) +\n  facet_wrap(facets = ~race) +\n  theme_bw()"
  },
  {
    "objectID": "WardDemographics.html",
    "href": "WardDemographics.html",
    "title": "Ward Demographics",
    "section": "",
    "text": "When ward boundaries remain stable between redistricting cycles, we can calculate ward demographics fairly easily.\nStep 1: calculate statistics for each ward in the starting year of the decade (e.g. 2010). Step 2: calculate statistics for each ward in the last year of the decade (e.g. 2020). Step 3: interpolate the statistics for the intervening election years. If a ward’s population was 100 in 2010 and 200 in 2020, I estimate that its population was 120 in 2012, 140 in 2014, etc. This is a crude estimate, but it should be directionally accurate, compared with just using a decennial benchmark.\nThe remainder of this chapter will describe how to match census data to Milwaukee County wards, which I believe have only changed during the official redistricting cycle during the past two decades."
  },
  {
    "objectID": "WardDemographics.html#by-voting-tabulation-district",
    "href": "WardDemographics.html#by-voting-tabulation-district",
    "title": "Ward Demographics",
    "section": "by voting tabulation district",
    "text": "by voting tabulation district\nDecennial census data is published in very small polygons called census blocks. In a place with stable municipal borders (like Milwaukee County), each census block should fit entirely within a single ward.\nAdditionally, the Census Bureau publishes block assignment files which explain the relationship between each block and several other higher orders of geography (e.g. tract, county subdivision, etc.). One of those higher geographies is the voting tabulation district (VTD). A VTD is essentially a ward. So, in the case of Milwaukee, the decennial census data includes the VTD, or ward number, for the wards drawn in the preceding redistricting cycle. The 2010 census data includes the name for each ward drawn in 2002. The 2020 census data includes the ward name from 2011.\nIn the case of Milwaukee County, I manually confirmed that the VTD names from the end of the decade matched the ward names assigned at the beginning of the decade.\nSee data/ subdirectory for more details."
  },
  {
    "objectID": "WardDemographics.html#by-spatial-join",
    "href": "WardDemographics.html#by-spatial-join",
    "title": "Ward Demographics",
    "section": "by spatial join",
    "text": "by spatial join\nWe also want to know which ward a census block was subsequently assigned to in the next redistricting process. To do this, I find a central point within each census block polygon. Then I intersect that coordinate point with the target ward polygons. After removing the spatial features, I’m left with a simple file containing a column with census block FIPS codes and another column with ward names.\nSee the file data/crosswalks/Build2010Crosswalk.R for an example of intersecting blocks with wards."
  },
  {
    "objectID": "WardDemographics.html#aggregating-demographics",
    "href": "WardDemographics.html#aggregating-demographics",
    "title": "Ward Demographics",
    "section": "Aggregating demographics",
    "text": "Aggregating demographics\nOnce we have a file matching each census block to a ward, we can aggregate statistics from the census block level into the voting wards.\nSee the file data/ward-demographics/AggregateWardDemographics.R for a demonstration of this.\nThese ward-level demographic statistics could be further aggregated into reporting units following the methodology laid out in the “Reporting Units vs. Wards” chapter."
  },
  {
    "objectID": "ReportingUnitsVsWards.html",
    "href": "ReportingUnitsVsWards.html",
    "title": "Reporting Units vs. Wards",
    "section": "",
    "text": "Wards are the most basic building block of the election system. All land in the state, populated or otherwise, must be assigned to a ward. When preparing to vote, you look up your ward’s polling place. All the other residents of your ward share the same elected officials, so the ballots for everyone living in the ward are identical.11 Sometimes this isn’t true. For instance, a special election for a Milwaukee Aldermanic seat took place during the Spring 2023 election. The entire Spring election was held under the new wards drawn during the 2021 redistricting cycle. The new Aldermanic districts don’t formally take effect until 2024, so the special election was technically held for the version of the district drawn in 2011. This caused some wards to be split, meaning that people living in the same ward had to receive different ballots based on whether they lived in the 2011 version of the aldermanic district or not. Another exception involves school districts, which are allowed to straddle ward lines.\nIn Wisconsin, official election results are not reported by ward. Rather, they are officially tabulated by “reporting unit.” Under specific, but common, conditions, local administrators can combine multiple adjacent wards into a single reporting unit. All the wards in a reporting unit must have identical races on the ballot during that election. Only municipalities with populations below 35,000 are allowed to create multi-ward reporting units. For larger municipalities, each reporting unit is a single ward.\nThe Wisconsin Election Commission publishes what they call “Ward by Ward Report” files, but this is a misnomer. Really, they are “Reporting unit by Reporting unit” results. The official results look something like this."
  },
  {
    "objectID": "ReportingUnitsVsWards.html#where-can-i-get-updated-ward-boundaries",
    "href": "ReportingUnitsVsWards.html#where-can-i-get-updated-ward-boundaries",
    "title": "Reporting Units vs. Wards",
    "section": "Where can I get updated ward boundaries?",
    "text": "Where can I get updated ward boundaries?\nThe Wisconsin Legislative Technology Services Bureau (LTSB) collects updated municipal and ward boundary information from local governments twice a years, in January and July. Unfortunately, these dates do not exactly correspond with elections, which generally occur in January, April, August, and November. It’s not uncommon for wards to be referenced in the names of reporting units which do not exist in the most recent vintage of the LTSB ward GIS file.\nIf you’re trying to find ward polygons right after an election, I recommend starting with the most recent LTSB file. If you identify inconsistencies between the list of wards referenced in the reporting unit names and the actual wards existing in the LTSB file, your best option is to visit the problem county’s “Land Information Office.” Literally, google “[COUNTY NAME] LAND INFORMATION OFFICE.” Sometimes, the updated ward boundary file will be available to download off the county LIO website. If not, try emailing or calling the office and asking for “a GIS file containing the ward boundaries used in the [MONTH YEAR] election.”"
  },
  {
    "objectID": "ReportingUnitsVsWards.html#disaggregating-reporting-units-to-wards",
    "href": "ReportingUnitsVsWards.html#disaggregating-reporting-units-to-wards",
    "title": "Reporting Units vs. Wards",
    "section": "Disaggregating reporting units to wards",
    "text": "Disaggregating reporting units to wards\nThe LTSB disaggregates the reporting unit results of each partisan election into individual wards using a methodology described in detail here. Basically, they rely on their most recent ward layer and use census-derived population estimates to come up with disaggregation factors. They also use sensible workarounds for edge cases that occur when the wards referenced by an election’s reporting units are inconsistent with the wards in their latest statewide file.\nThe LTSB also uses a similar methodology to disaggregate prior election results with different ward boundaries into the current ward boundary map. This methodology has great advantages for researchers who need consistent units of analysis across time.\nA disadvantage to disaggregated wards is that the information presented is not literally accurate. It should be close enough for statistical analysis purposes, but sometimes the researcher’s primary interest is actually presenting the official, legal election results."
  },
  {
    "objectID": "ReportingUnitsVsWards.html#aggregating-wards-to-reporting-units",
    "href": "ReportingUnitsVsWards.html#aggregating-wards-to-reporting-units",
    "title": "Reporting Units vs. Wards",
    "section": "Aggregating wards to reporting units",
    "text": "Aggregating wards to reporting units\nEspecially given the increasingly fraught public rhetoric around election integrity, I often find it preferable to present the official election data as accurately as possible. In certain kinds of research projects, it may also aid overall accuracy to use wholly accurate, non-disaggregated election returns.\nTo create reporting unit shapefiles, follow these steps:\n\nSelect the ward GIS file from the time period closest to the election you want to map.\nIdentify the individual wards which make up each reporting unit.\nMatch those wards to the GIS file, keeping the reporting unit name as an additional field.\nGroup by the reporting unit name, and dissolve the constituent ward polygons into a larger reporting unit polygon.\n\nHere is an example, using Milwaukee County data from the 2020 presidential election.\nThe official election results look like this.\n\n\nShow the code\npres20\n\n\n# A tibble: 476 × 5\n   county_fips reporting_unit                  total biden trump\n   <chr>       <chr>                           <dbl> <dbl> <dbl>\n 1 55079       Village of BAYSIDE Wards 1,3     1049   719   323\n 2 55079       Village of BAYSIDE Wards 1S,3S     71    47    24\n 3 55079       Village of BAYSIDE Wards 2,4     1253   910   327\n 4 55079       Village of BAYSIDE Ward 5         706   508   192\n 5 55079       Village of BROWN DEER Wards 1-2  2494  1892   553\n 6 55079       Village of BROWN DEER Wards 3-4  2489  1683   771\n 7 55079       Village of BROWN DEER Wards 5-6  2480  1750   686\n 8 55079       Village of FOX POINT Wards 1-4   2202  1533   641\n 9 55079       Village of FOX POINT Wards 5-9   2790  1959   788\n10 55079       Village of GREENDALE Wards 1-2   1765   824   916\n# … with 466 more rows\n\n\nThe wards look like this\n\n\nShow the code\nward.shp.2020\n\n\n# A tibble: 570 × 3\n   county_fips ward_name                                                geometry\n   <chr>       <chr>                                          <MULTIPOLYGON [°]>\n 1 55079       Bayside - V 1    (((-87.90525 43.17631, -87.90575 43.17631, -87.…\n 2 55079       Bayside - V 1S   (((-87.90774 43.17631, -87.90808 43.17631, -87.…\n 3 55079       Bayside - V 2    (((-87.90501 43.18393, -87.90482 43.18392, -87.…\n 4 55079       Bayside - V 3    (((-87.91764 43.1921, -87.91694 43.19213, -87.9…\n 5 55079       Bayside - V 3S   (((-87.92205 43.19104, -87.9222 43.19104, -87.9…\n 6 55079       Bayside - V 4    (((-87.89894 43.1922, -87.89815 43.19217, -87.8…\n 7 55079       Bayside - V 5    (((-87.90113 43.17482, -87.90125 43.1751, -87.9…\n 8 55079       Brown Deer - V 1 (((-87.95951 43.18644, -87.95919 43.1862, -87.9…\n 9 55079       Brown Deer - V 2 (((-87.98452 43.17997, -87.98452 43.18014, -87.…\n10 55079       Brown Deer - V 3 (((-87.99448 43.17787, -87.99448 43.17837, -87.…\n# … with 560 more rows\n\n\nThe next step is to extract the individual wards from each reporting unit. First, separate the main elements of the reporting_unit string, like so:\n\n\nShow the code\nreporting.units <- pres20 %>%\n  select(reporting_unit) %>%\n  separate(reporting_unit, into = c(\"municipality\", \"wards\"), \n           sep = \" Wards | Ward \", remove = F) %>%\n  separate(municipality, into = c(\"ctv\", \"muni\"), sep = \" of \") %>%\n  mutate(ctv = str_sub(ctv, 1, 1))\n\nreporting.units\n\n\n# A tibble: 476 × 4\n   reporting_unit                  ctv   muni       wards\n   <chr>                           <chr> <chr>      <chr>\n 1 Village of BAYSIDE Wards 1,3    V     BAYSIDE    1,3  \n 2 Village of BAYSIDE Wards 1S,3S  V     BAYSIDE    1S,3S\n 3 Village of BAYSIDE Wards 2,4    V     BAYSIDE    2,4  \n 4 Village of BAYSIDE Ward 5       V     BAYSIDE    5    \n 5 Village of BROWN DEER Wards 1-2 V     BROWN DEER 1-2  \n 6 Village of BROWN DEER Wards 3-4 V     BROWN DEER 3-4  \n 7 Village of BROWN DEER Wards 5-6 V     BROWN DEER 5-6  \n 8 Village of FOX POINT Wards 1-4  V     FOX POINT  1-4  \n 9 Village of FOX POINT Wards 5-9  V     FOX POINT  5-9  \n10 Village of GREENDALE Wards 1-2  V     GREENDALE  1-2  \n# … with 466 more rows\n\n\nNext, convert the wards field into a simple comma-separated list of wards. I’ve written a helper function which uses regular expressions to convert hyphentated ranges into lists of numbers.\n\n\nShow the code\n# expand a list of numbers including dashes into full list\nexpand_dash <- function(wardstring){\n  wardstring.elements <- unlist(str_split(wardstring, \",\"))\n  wardstring.list <- lapply(\n    X = wardstring.elements,\n    FUN = function(text){\n      if(str_detect(text, \"-\")){\n        limits <- as.numeric(unlist(strsplit(text, '-')))\n        paste(seq(limits[1], limits[2]), collapse = \", \")\n      } else {\n        text\n      }\n    }\n  )\n  str_remove_all(paste(wardstring.list, collapse = \",\"), \" \")\n}\n\nreporting.units.2 <- reporting.units %>%\n  rowwise() %>%\n  mutate(wards = expand_dash(wards)) %>%\n  ungroup()\nreporting.units.2\n\n\n# A tibble: 476 × 4\n   reporting_unit                  ctv   muni       wards    \n   <chr>                           <chr> <chr>      <chr>    \n 1 Village of BAYSIDE Wards 1,3    V     BAYSIDE    1,3      \n 2 Village of BAYSIDE Wards 1S,3S  V     BAYSIDE    1S,3S    \n 3 Village of BAYSIDE Wards 2,4    V     BAYSIDE    2,4      \n 4 Village of BAYSIDE Ward 5       V     BAYSIDE    5        \n 5 Village of BROWN DEER Wards 1-2 V     BROWN DEER 1,2      \n 6 Village of BROWN DEER Wards 3-4 V     BROWN DEER 3,4      \n 7 Village of BROWN DEER Wards 5-6 V     BROWN DEER 5,6      \n 8 Village of FOX POINT Wards 1-4  V     FOX POINT  1,2,3,4  \n 9 Village of FOX POINT Wards 5-9  V     FOX POINT  5,6,7,8,9\n10 Village of GREENDALE Wards 1-2  V     GREENDALE  1,2      \n# … with 466 more rows\n\n\nNext, convert this table to long format, so that each row represents a single ward within a reporting unit. I also create a ward_name variable which matches the format used by the ward_name variable in the GIS file.\n\n\nShow the code\nwards.in.reporting.units <- reporting.units.2 %>%\n  separate(col = wards, into = c(\"w1\",\"w2\",\"w3\",\"w4\",\"w5\"), sep = \",\", fill = \"right\") %>%\n  pivot_longer(cols = starts_with(\"w\"), names_to = \"wardcount\", values_to = \"ward\") %>%\n  filter(!is.na(ward)) %>%\n  select(-wardcount) %>%\n  mutate(ward_name = paste(str_to_title(muni), \"-\", ctv, ward))\n# nrow(ward.shp.2020) == nrow(wards.in.reporting.units)\n# table(ward.shp.2020$ward_name %in% wards.in.reporting.units$ward_name)\nwards.in.reporting.units\n\n\n# A tibble: 570 × 5\n   reporting_unit                  ctv   muni       ward  ward_name       \n   <chr>                           <chr> <chr>      <chr> <chr>           \n 1 Village of BAYSIDE Wards 1,3    V     BAYSIDE    1     Bayside - V 1   \n 2 Village of BAYSIDE Wards 1,3    V     BAYSIDE    3     Bayside - V 3   \n 3 Village of BAYSIDE Wards 1S,3S  V     BAYSIDE    1S    Bayside - V 1S  \n 4 Village of BAYSIDE Wards 1S,3S  V     BAYSIDE    3S    Bayside - V 3S  \n 5 Village of BAYSIDE Wards 2,4    V     BAYSIDE    2     Bayside - V 2   \n 6 Village of BAYSIDE Wards 2,4    V     BAYSIDE    4     Bayside - V 4   \n 7 Village of BAYSIDE Ward 5       V     BAYSIDE    5     Bayside - V 5   \n 8 Village of BROWN DEER Wards 1-2 V     BROWN DEER 1     Brown Deer - V 1\n 9 Village of BROWN DEER Wards 1-2 V     BROWN DEER 2     Brown Deer - V 2\n10 Village of BROWN DEER Wards 3-4 V     BROWN DEER 3     Brown Deer - V 3\n# … with 560 more rows\n\n\nThe both the original ward GIS file and the wards retrieved from reporting units show 570 named wards in Milwaukee County. Moreover, the names from each ward_name column match each other exactly.\nI join the two files, group by the reporting_unit variable, and summarize, combining the individual ward polygons using sf::st_union().\n\n\nShow the code\nreporting.unit.shp.2020 <- ward.shp.2020 %>%\n  inner_join(wards.in.reporting.units) %>%\n  group_by(reporting_unit) %>%\n  summarise(geometry = st_union(geometry))\n\n\nJoining with `by = join_by(ward_name)`\n\n\nShow the code\nreporting.unit.shp.2020\n\n\n# A tibble: 476 × 2\n   reporting_unit                                                       geometry\n   <chr>                                                           <POLYGON [°]>\n 1 City of CUDAHY Wards 1-3   ((-87.85958 42.95913, -87.8581 42.95914, -87.8576…\n 2 City of CUDAHY Wards 10-12 ((-87.86847 42.93365, -87.86806 42.93366, -87.867…\n 3 City of CUDAHY Wards 13-15 ((-87.86349 42.93008, -87.86341 42.93008, -87.863…\n 4 City of CUDAHY Wards 4-6   ((-87.84925 42.95104, -87.84816 42.95105, -87.846…\n 5 City of CUDAHY Wards 7-9   ((-87.86534 42.94457, -87.86506 42.94457, -87.864…\n 6 City of FRANKLIN Ward 1    ((-88.00984 42.88712, -88.00985 42.88687, -88.009…\n 7 City of FRANKLIN Ward 10   ((-87.96153 42.92292, -87.96181 42.92299, -87.962…\n 8 City of FRANKLIN Ward 11   ((-87.96004 42.91043, -87.96001 42.9113, -87.96 4…\n 9 City of FRANKLIN Ward 12   ((-87.95063 42.89454, -87.95058 42.89598, -87.950…\n10 City of FRANKLIN Ward 13   ((-87.99709 42.90148, -87.99776 42.90148, -87.997…\n# … with 466 more rows\n\n\n\n\nShow the code\nplot(ward.shp.2020$geometry)\nplot(reporting.unit.shp.2020$geometry)\n\n\n\n\n\n\n\nWard polygons, 2020\n\n\n\n\n\n\n\nReporting unit polygons, 2020 presidential election"
  },
  {
    "objectID": "RegisteredVoters.html",
    "href": "RegisteredVoters.html",
    "title": "Registered Voters",
    "section": "",
    "text": "Tracking registered voters is useful for measuring voter participation, but several aspects of Wisconsin election administration complicate its use."
  },
  {
    "objectID": "RegisteredVoters.html#ward-files",
    "href": "RegisteredVoters.html#ward-files",
    "title": "Registered Voters",
    "section": "Ward files",
    "text": "Ward files\nFor one, the most frequently updated registered voter statistics are published at the ward, not reporting-unit level. These ward-level files are published by the Wisconsin Election Commission showing totals usually on the first day of each month.\nThis ward-level data runs into the same caveats described in the previous section. To directly compare these numbers with election results, you would first need to aggregate the wards into the reporting units used in that specific election. Ward boundaries can change in ways that make these comparisons difficult or impossible.\nAnother problem is that none of the monthly registered voter files directly correspond to the Election Day universe of registered voters, as none of Wisconsin’s various election days falls on the first of a month. Moreover, Wisconsin still maintains same-day registration. You can show up at your local polling place, register, and immediately cast a ballot. As a result, many wards end election day with more registered voters than they began it with. In places with a highly transient population, like college campuses, the number of election day registrants can be very high.\nAlso, the state’s registration system works hard to transfer the identify of registered voters when they move within the state. If you are registered in Oshkosh, move to Appleton, and then register at your new polling place on Election Day, the state will transfer your old voter registration in their database. This prevents an individual voter from being registered in two places at once. It also means that same day registration can actually reduce the number of registered voters in a ward versus what it held entering election day.\nFor all these reasons, it’s better to use the registered voter file from the first day of the month following the election than it is from the first day of the month containing the election day."
  },
  {
    "objectID": "RegisteredVoters.html#reporting-unit-election-reports",
    "href": "RegisteredVoters.html#reporting-unit-election-reports",
    "title": "Registered Voters",
    "section": "Reporting Unit election reports",
    "text": "Reporting Unit election reports\nThe WEC also publishes another file of detailed election statistics recorded at the reporting unit level. Formerly called the EL-190 report, it includes 3 voter registration columns.\n\nOpen Registrants - includes everybody who was registered to vote in that reporting unit after the last election or who registered prior to the 19th day before the current election.\nLate Registrants - includes those who registered to vote from the 19th prior to the election through the last Friday before the election. No one in Wisconsin can register to vote on the Saturday, Sunday, or Monday before the election on Tuesday. I believe this rule is to give administrators time to print the voter rolls for each ward.\nElection Day Registrants - includes everybody who registers to vote on election day\n\nBy adding these three columns, you can get a figure of total registered voters for each reporting unit which includes election day registrants."
  }
]